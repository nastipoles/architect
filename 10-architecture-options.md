# 10. Анализ и описание архитектурных опций и обоснование выбора

## Архитектурный стиль: Микросервисы vs. Монолит vs. Модульный монолит

С монолитным приложением проще начать разработку, меньше DevOps-составляющей, цельный деплой, однако сложная масштабируемость при пиковых нагрузках, невозможность независимо развивать разные блоки.

С микросервисной архитектурой возможно независимое масштабирование сервисов, упрощение интеграций, гибкость выбора технологий и темпов разработки. Однако повышенная сложность DevOps, нужны продвинутые инструменты мониторинга, управления конфигурациями, знаний в команде.

**Принято решение использовать микросервисную архитектуру**, т.к. ожидается высокая нагрузка (массовые спортивные мероприятия), нужно независимо масштабировать компоненты. Есть широкий спектр функционала (социальные функции, аналитика, магазин, промо) — удобнее разбить на отдельные сервисы. Компания ориентирована на облачную инфраструктуру, есть DevOps-команда с опытом использования Kubernetes и контейнеризации.

## Средства интеграции и коммуникации: REST, брокер сообщений, gRPC

Если использовать только REST, то будет простая концепция, понятная многим разработчикам. Но при росте числа сервисов увеличивается риск «каскадных» зависимостей, сложнее обрабатывать массовые события (соревнования).

Если использовать событийную шину (RabbitMQ) + REST, то возможна асинхронная обработка, снижение пиков, удобная реализация геймификации (очки, достижения, уведомления). При этом сложнее в администрировании (дополнительный брокер), меняется парадигма разработки.

При использовании GraphQL будут гибкие запросы, удобен на фронте (особенно мобильном), но может быть избыточно сложно, требует четкого проектирования схемы, не решает вопрос асинхронного взаимодействия.

При использовании gRPC будет высокая производительность, двоичный протокол, удобен для межсервисного общения, но это требует дополнительной инфраструктуры, не все команды знакомы, сложности отладки.

**Принято решение использовать RabbitMQ + REST**, т.е. REST для «внешних» API (Mobile, Web) и RabbitMQ для асинхронных событий (окончание тренировки, начисление очков, заказ). Т.к. REST проще для фронтенда и интеграции с внешними партнерами, а RabbitMQ обезопасит от «лавинообразной» нагрузки при массовых событиях и улучшит связность между микросервисами.

## Тип СУБД: Реляционная база vs. NoSQL vs. Гибрид

Если использовать SQL, то будет ACID, транзакционная целостность, удобные инструменты анализа и репликации. Из минусов можно выделить большие объемы полуструктурированных данных, может быть сложнее хранить социальную ленту.

Если использовать NoSQL, то будет гибкая структура, горизонтальное масштабирование. Но при этом отсутствие жестких транзакций (по умолчанию), сложнее построить отчетность, команде может не хватать опыта.

Также можно использовать комбинированный подход (SQL для транзакционных и NoSQL для соц. функций), тогда каждая задача решается оптимальным хранилищем. Но усложняется инфраструктура (две или более БД).

**Принято решение использовать SQL во всех основных микросервисах + Data Lake для аналитики**, т.к. структура данных по большинству доменов (профиль, заказы, результаты тренировок) достаточно стабильна. Масштабируемость SQL решается через кластеризацию в облаках. Социальная лента и комментарии также могут храниться в SQL.

## Безопасность и управление пользователями: IAM-платформа vs. собственная реализация

Можно использовать самописное решение, что дает полный контроль, гибкость, но подразумевает большие затраты на поддержку, потенциальные уязвимости.

Если использовать готовую IAM-платформу (Keycloak, Okta, Auth0, Azure AD B2C) — то будет поддержка стандартов (OAuth2, OpenID Connect), богатый функционал, выше уровень безопасности, встроенные механизмы SSO, масштабирования. Но зависимость от внешнего продукта, возможная сложность кастомизации.

**Принято решение использовать Keycloak**, т.к. это сокращает время разработки и дает готовые механизмы OAuth2, управления ролями, соединения с соцсетями. И дает соответствие корпоративным политикам безопасности (крупные компании уже используют Keycloak).

## Подход к масштабированию: Containers/Kubernetes vs. VM vs. Serverless

При использовании VM (классические виртуальные машины) будет знакомый подход, меньше «слоев» абстракции. Но неудобно управлять десятками/сотнями VM, ручное масштабирование.

При Serverless (FaaS) будет подход «плати по факту» выполнения, простая масштабируемость, но может быть сложно для долгоживущих процессов, ограниченные среды исполнения, сложная отладка.

При контейнеризации и Kubernetes — де-факто стандарт для микросервисов, удобный декларативный подход к масштабированию, гибкость в выборе облака. Но требует опыта DevOps, настройку CI/CD.

**Принято решение использовать Kubernetes**, т.к. это соответствует стратегии микросервисов, дает возможность горизонтального масштабирования и компания уже имеет опыт контейнеризации.
